# Проверка синтаксиса
print("Введение в объектно-ориентированное программирование")

# Парадигмы програмирования - это стиль программирования.
# Существует множество различых парадигм программирования.
# Чтобы программировать профессионально, нужно изучить парадигмы либо объектно-ориентированого, либо функционального программирования.
# Одним из фундаментальных различий между разными парадигмами программирования является управление состоянем.
print("Состояние - это значение переменных в программе при её работе.")
print("Глобальное состояние - значение глобальных переменных в программе при её работе.")
#________________________________________________________________________________________________________________________________
# Процедурное программирование

# В I части программировали, используя парадигму процедурного программирования - стиль программирования,
# в котором пишется последовательность шагов по направлению к решению, и каждый шаг изменяет состояние программы.
# В процедурном программировании пишется код, чтобы "сделать это, за тем это" 
x = 2
y = 4
z = 8
xyz = x + y + z
print(xyz)      # Каждая строка в этом примере изменяет состояние программы
# Когда вы используете процедурное программирование, то созраняете данные в глобальных переменных и управляете ими при помощи функций.
rock = []
country = []
def collect_songs():
    song = "Укажите песню: "
    ask = "Введите р (рок) или к (кантри). Введите X для выхода: "

    while True:
        genre = input(ask)
        if genre == "Х":
            break
        if genre == "р":
            rk = input(song)
            rock.append(rk)
        elif genre ==("к"):
            cy = input(song)
            country.append(cy)
        else:
            print("Неверно.")
    print(rock)
    print(country)
collect_songs()

# Процедурное программирование подхоидт для написания небольших программ вроде этой, однако из-за того, что все состояния 
# программы сохраняются в глобальных переменных, когда код становится больше, появляются пролемы.
# Более того, этот подход к программированию опирается на побочные эффекты.
print("Побочный эффект - изменение состояния глобальной переменной.")
# При процедурном программировнии часто сталкиваешься с непреднамеренными побочными эффектами, такими как случайное увеличение переменной.
# Эта проблема привела к развитию паралигм ООП и функционального программирования, и эти парадигмы используют разные подходы к её решению.

#________________________________________________________________________________________________________________________________
# Функциональное программирование
# Функциональное программирование происходит от лямбда-исчисления - наименьшего в мире универсального языка программирования 
# Функциоанльное программирование решает проблемы процедурного программирования с помощью устранения глобального состояния.
# Функциональный программист полагается на функции, которые не используют и не изменяют глобальное состояние;
# единственное используемое ими состояние - параметры, которые вы передаете в функцию.
# Результат, возвращаемый функцией, обычно передают в другую функцию.
# Отказ от глобального состояния избавляет от побочных эффектов и сопутствующих проблем.
a = 0
# Пример функции, имеющей побочные эффекты:
def increment():
    global a
    a += 1
# Пример функции без побочных эффектов:
def increment1(a):
    return a + 1
# У первой функции есть побочные эффекты, поскольку она полагается на данные за её пределами и изменяет данные вне текущей функции,
# У второй функции нет побочных эффектов, так как она не полагается на данные за её пределами и не изменет эти данные.

# Преимущество функционального программирования заключается в том, что оно устраняет целую категорию ошибок,
# вызванных глобальным состоянием. (его просто нет)
# Его недостаток заключается в том, что некоторые проблемы легче осмыслить при помощи состояния. 

#________________________________________________________________________________________________________________________________
# Объектно-ориентированное программирование
# Парадигма объектно-ориентированного программирования также решает проблемы, возникащие в процедурном программировании,
# но здесь состояние сохраняется не в функцию, а в объктах.
# В объектно-ориентированном программировании классы определяют набор объектов, которые могут взаимодействовать между собой.
print("Классы - механизмы, позволяющие програмисту классифицировать и сгруппировывать похожие объекты.")
print("Каждый объект - это экземляр класса") # Термины "объект" и "экземпляр" взаимозаменяемы

# В Python класс является составной инструкцией с заголовком и телом.
# class имя: тело
# Имя по соглашению должно начинаться с прописной буквы и записываться в горбатом регистре (LikeThis) (без нижних подчёркиваний)
print("Метод - тело в классе, которое может быть простой или составной инструкцией")
## При создании метода нужно всегда определять хотя бы один параметр, поскольку, когда метод вызывается в объекте,
## Python авоматически передаёт вызвавший метод объект в этот метод в качестве параметра

# Можно использовать параметр self, чтобы определить переменную экзампляра - переменную, принадлежащую объекту.
# Если создать несколько объектов, у них всех будут разные значения переменных экземпляра.
# Переменные экземпляра объявляются с помощью синтаксиса self.имя_переменной = значение переменной.
# Обычно переменные экземпляра определяются внутри специального метода __init__ (initialize - инициализировать),
# который вызывается Python при создании объекта
# Ниже приведён пример калсса, пердставляющего апельсин
class Orange:
    def __init__ (self, w, c): # По соглашению, первый параметр метода всгда называется self.
        self.weight = w
        self.color = c
        self.mold = 0
        print("Создано!")
    # Апельсины не определяются только весом и цветом - они делают разные вещи, например, гниют.
    def rot(self, days, temp):
        self.mold = days * temp

print\
("""Любой метод, окружённый двойными нижними подчёркиваними (как __init__) вляется магическим классом,
который Python использует для особых целей, таких как создание объекта.""")

print("Создание нового объекта называется созданием экземляра класса.")
# Синтаксис создания объекта в классе такой же, как у функции (при создании не нужно передавать self, Python сделает это автоматически)
orl = Orange(10, "тёмный апельсин") # Тащемта создание
print(orl) # Python сообщает о местонахождении в памяти этого объекта

# Как только создан объект, можно получить значение его переменных экземпляра с помощью синтаксиса имя_объекта.имя_переменной
print(orl.weight)
print(Orange(100, "светлый апельсин").color) # 1 часть - создание, color выводит значение переменной только что созданного объекта
# имени у него не существует (насколько понял), но местонахожение есть
print(Orange(100, "светлый апельсин")) # Создание экземпляра класса без имени

# Изменение переменных экземпляра (нужно имя)
orl.weight = 50
orl.color = "зелёный апельсин"
print(orl.weight)
print(orl.color)

# Используя класс Orange, можно создать множестов апельсинов:
or1 = Orange(4, "светлый апельсин")
or2 = Orange(8, "тёмный апельсин")
or3 = Orange(14, "желтый апельсин")

orange = Orange(6, "апельсин")
print(orange.mold)
orange.rot(10, 33)
print(orange.mold)

# В классе можно определять множестов методов. Ниже приведён пример построения модели прямоугольника при помощи метода для расчёта
# его площади и другого метода для изменения его размера.
class Rectangle():
    def __init__(self, w, l):
        self.width = w
        self.len = l
        print("Прямоугольник создан!")

    def area(self):
        return self.width * self.len

    def change_size(self, w, l):
        self.width = w
        self.len = l

rectangle = Rectangle(10, 20)
print(rectangle.area())
rectangle.change_size(20, 40)
print(rectangle.area())

# У объектно-ориентированного программирования есть несколько преимуществ. Эта парадигма способствует посторному использованию
# кода и вследствие этого сокращает количество времени, необходимое на разработку и обслуживанию кода.
# Проблемы разбиваются на множество фрагментов, благодаря чему код становится легче поддерживать.

# Недостатки объектно-ориентированного программирования можно считать то, что создание прорамм требует больше усилий, поскольку
# их разработка включает огромный объем планирования.


















