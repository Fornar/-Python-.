print("Четыре столпа объектно-ориентированного программирования".upper())
# В ООП есть четыре главные концепции:
# инкапсуляция, абстракция, полиорфизм и наследование.
# Чтобы язык програмировани действительно моно было назвать объектно-ориентированным,
# как Python, Java или Ruby, в нём должны присутствовать все четыре концепции.

#_________________________________________________________________________________________________________________________________
# Инкапсуляция
# Инкапсуляция относится к двум концепциям. Первая заключается в том, что в ООП переменные (состояние)
# и методы (для изменения состояния либо выполнения вычислей, использующих состояние) группируются в единой целое - объект.
class Rectangle():
    def __init__(self, w, l):
        self.width = w
        self.len = l

    def area(self):
        return self.width * self.len
    # В этом случае переменные экземплра класса len и width хранят состояние объекта.
    # Состояние объекта сгруппировано в том же блоке (объекте), что и метод area.

# Втора концепция, собственно, инкапсуляция, заключается в сокрытии внутренних данных класса для предотвращения получения клиентом
# (кодом вне класса, который использует объект) прямого доступа к этим данным.
class Data:
    def __init__(self):
        self.nums = [1, 2, 3, 4, 5, 6]
        
    def change_data(self, index, n):
        self.nums[index] = n
# Как только был создан объект Data, есть два способа изменить элементы в nums - при помощи методы change_data или напрямую
# получая доступ к переменной экземпляра с помощью объекта Data.
data_one = Data()
data_one.nums[0] = 100
print(data_one.nums)

data_one.change_data(1, 200)
print(data_one.nums)
# Если осуществить изменение списков на кортежи, любой код клиента, пытающийся изменить элементы в переменной nums, как
# nums[0] = 100, больше не будет работать, поскольку кортежи неизменяемы.

print("""Многие языки программирования решают проблему доступа, разрешая программистам определять закрытые переменные и закрытые
методы - переменные и методы, к которым могут обращаться объекты в коде, реализующем различные методы, но клиент не может.""")

# Закрытые переменные и методы полезны, когда есть метод или переменные, используемые внутри класса, но вы планируете
# позже изменить реализацию своего кода (или желаете изменить гибкость этой опции) и потому не хотите, чтобы тот, кто
# использует этот класс, полгалася на них (ведь они могуть изменить и нарушить код клиента).
# В противоположность, открытые переменные - это те, к которым клиент может получить доступ.

# В Python нет закрытых переменных. Вместо них используются конвенции (соглашения) имён.
class PublicPrivateExample:
    def __init__(self):
        self.public = "безопасно"
        self._unsafe = "опасно"
        
    def public_method(self):
        # клиенты могут это использовать
        pass
    
    def _unsafe_method(self):
        # клиенты не должны это использовать
        pass
        self.public = "безопасно"
        self._unsafe = "опасно"
exp = PublicPrivateExample()
print(exp.public_method())
# если имя метода или переменной начинается с символа подчёркивания, их нельзя использовать Хprint(exp._unsage_method())Х,
# но возможно, правда выидет ошибка.

#_________________________________________________________________________________________________________________________________
# Абстракция
print('''Абстракция - это процесс "отнятия или удаления у чего-то характеристик с целью свдени его к набору основных,
существенных характеристик"''')
# В ООП абстракция используется, когда объекты моделируются с использованием классов, а ненужные подробности опускаются.

#_________________________________________________________________________________________________________________________________
# Полиморфизм
print('''Полиморфизмом называют "способность (в программировании) представлять один и тот же интерфейс для разных базовых форм
(типов данных.''')
# Интерфейс - это функция или метод.
# Пример представления одного и того же интерфейса для разных типов данных:
print('''ООО "Либераху порвало"''')
print(200)
print(100.0)
# То есть предоставляется один и тот же интерфейс для разных типов данных (а не print_string, к примеру)

# Встроенная функция type позвращает тип данных объекта
print(type('''ООО "Либераху порвало"'''))
print(type(200))
print(type(100.0))

#_________________________________________________________________________________________________________________________________
# Наследование
# Когда создаётся клсс, он может наследовать методы и переменные от другого класса.
# Класс, от которого наследуют, называется родительским, а класс, котрый наследует, - дочерним.
# В этом разделе моделируются фигуры, используя наследование.

class Shape():
    def __init__(self, w, l):
        self.width = w
        self.len = l

    def print_size(self):
        print("""{} на {}
              """.format(self.width,
                         self.len))
my_shape = Shape(20, 25)
my_shape.print_size()
# Можно определить дочерний класс, наследующий от родительского, передав имя родительского класса в качестве параметра дочернему
# классу при его создании.

class Square(Shape):
    pass                    # Ключевое слово, сообщающее ничего не делать. :D

a_square = Square(20, 20)
a_square.print_size()
# Благодаря наследованию можно создавать объект Square, передавать ему ширину и длину и вызывать в нём метод print_size
# без необходимости писать еще какой-либо код (за исключением pass) в классе Square. Такое сокращение очень важно,
# поскольу избегание повторений кода уменьшает программу и делает ее более управляемой.

# Дочерний класс не отличается от любого другого - можно определять в нем методы и переменные, не затрагивая родительский класс.
# Когда дочерний класс наследует метод от родительского класса, его можно переопределить, определив новый метод с таким же именем,
# как и метода, который был унаследован.

class Rectangle(Shape):
    def area(self):
        return self.width * self.len
    def print_size(self):           # Новый метод переопределяет родительский метод
        print("""{} by {}
              """.format(self.width,
                         self.len)) # Способность дочернего класса изменять реализацию метода,
                                    # унаследованного от его родительского класса, называется переопределением метода.

a_rectangle = Rectangle(20, 25)
print(a_rectangle.area())
a_rectangle.print_size()

#_________________________________________________________________________________________________________________________________
# Композиция
# Композиция моздает отношение "имеет", сохраняя объект в другом объекте как переменную.
# Например, композиция может использоваться для преставления отношения между собакой и ее хозяином.
class Dog():
    def __init__(self,
                 name,
                 breed,
                 owner):
        self.name = name
        self.breed = breed
        self.owner = owner

class Person:
    def __init__(self, name):
        self.name = name
# Затем, когда создаётся объект Dog, то следует передать объект Person в качестве параметра хозяина.
mick = Person("Мик Джаггер")
stan = Dog("Стенли",
           "Бульдог",
           mick)
print(stan.owner.name)
# Теперь объект stan с именем "Стэнли" имеет хозяина - объект Person с именем "Мик Джаггер", хранящийся в переменной
# экземпляра класса owner






























