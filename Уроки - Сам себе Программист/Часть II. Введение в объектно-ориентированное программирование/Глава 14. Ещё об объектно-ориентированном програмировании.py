print("Ещё об объектно-ориентированном программировани".upper())
#=================================================================================================================================
# Переменные класса и переменные экземпляра.
# Каждый класс Python - объект, являющийся экземпляром "типа" класса.
class Square:
    pass
print(Square)

print("У классов есть два типа переменных - переменые класса и переменные экземпляра класса.")
# До этого момента встречались только переменные экземпляра класса.
# Переменные экземпляра класса принадлежат объектам.
class Rectangle():
    def __init__(self, w, l):
        self.width = w
        self.len = l

    def print_size(self):
        print("""{} на {}
              """.format(self.width,
                         self.len))

my_rectangle = Rectangle(10, 24)
my_rectangle.print_size()
# В этом примере width и len - переменные экземпляра класса.

# Переменные класса принадлежат объекту, который Python создаёт для каждого определения класса, и объектам, которые они создают.
# Переменные класса позволяют обмениваться данными между всеми экземплярами класса без полагания на глобальные переменные.
class Rectangle():
    recs = []
    
    def __init__(self, w, l):
        self.width = w
        self.len = l
        self.recs.append((self.width,
                          self.len))

    def print_size(self):
        print("""{} на {}
              """.format(self.width,
                         self.len))

r1 = Rectangle(10, 24)
r2 = Rectangle(20, 40)
r3 = Rectangle(100, 200)

print(Rectangle.recs)# К ним можно получить доступ с помощью объектов
print(r1.recs) # и объектов, созданных объектами класса.

#_________________________________________________________________________________________________________________________________
# Магические методы
# Каждый класс в Python наследуется от родительского класса Object.
# Python использует методы, унаследованные от Object, в различных ситуациях - например, когда вводится объект.
class Lion:
    def __init__(self, name):
        self.name = name
# Когда вы выводите объект Lion, Python вызывает в нем магический метод __repr__, унаследованный этим объектом от Object,
# и выводит то, что возвращает __repr__.
    def __repr__(self):     # Можно переопределить унаследованный метод, чтобы изменить его вывод.
        return self.name

lion = Lion("Дилберт")
print(lion) # из-за переопределённого метода __repr__ теперь выводится self.name, а не сведения о его местонахождении.

# Операнды в выражении должны иметь магический метод, который оператор может использовать для оценки выражения.
# Если вы определите метод __add__ в классе, то сможете использовать создаваемые им объекты как операнды
# в выражении с оператором сложения.
class AlwaysPositive:
    def __init__(self, number):
        self.n = number

    def __add__(self, other): # При определении значения выражения с оператором сложения, Python вызывает метод __add__
# в первом объекте операнда, передаёт второй объект операнда в __add__ в качестве параметра и возвращает результат.
        return abs(self.n + # В этом случае __add__ использует встроенную функцию abs, чтобы вернуть абсолютное значение
                   other.n) # двух сложенных в выражении чисел. (неотрицательное число) 

x = AlwaysPositive(-20)
y = AlwaysPositive(10)

print(x + y)

#_________________________________________________________________________________________________________________________________
# Ключевое слово is
# Ключевое слово is возвращает значение True, если два объекта являются одним и тем же объектом, и False в противном случае.
class Person:
    def __init__(self):
        self.name = 'Боб'

bob = Person()
same_bob = bob
print(bob is same_bob)

another_bob = Person()
print(bob is another_bob)

# Используете ключевое слово is, чтобы проверить, присвоено ли переменной значение None
x = 10
if x is None:
    print("x равно None :(")
else:
    print("x не равно None")

x = None
if x is None:
    print("x равно None :(")
else:
    print("x не равно None")


















